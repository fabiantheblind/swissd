#target indesign/* * CONFIG * KNOWN BUGS AND TODO:  - there is actualy only one line possible, maybe change that. *                       - which color for the rectangle-line? *                       - the config.color is hidden in the code, would be nice to bring to top *                       - due to the fact the font is now transparent, the shadow will on                           the bottom will shine through this will generate a emboss effect.                           so atm its not possible to use shadow with faded. *                       - shear is not centered *                       - load a textfile and split in lines. */var config = {    pageWidth:      297,    pageHeight:     210,    gutter:         3,    lineHeight:     2,    // fontFamily:     'Dezen Pro   _Heavy',    // fontFamily:     'Populaire   Medium',    // fontFamily:     'Bebas Neue  Regular',    // fontFamily:     'Mountain Retreat    Condensed ',    // fontFamily:     'Museo Slab  1000',    // fontFamily:     'Sketch Rockwell Regular',    // fontFamily:     'TripleCondensedGothicRR Light   Regular',    fontFamily:     'TripleCondensedGothicRR Light  Regular',    contents:       [                        "we are the",                        "ocean",                        "nothing good",                        "has happened yet"                    ]};config.margins = {    top:            40,    right:          120,    bottom:         40,    left:           120};config.bounds = {    top:            config.margins.top,    right:          config.pageWidth - config.margins.right,    bottom:         config.pageHeight - config.margins.bottom,    left:           config.margins.left,    width:          config.pageWidth - (config.margins.right + config.margins.left),    height:         config.pageHeight - (config.margins.top + config.margins.bottom)};config.customization = {    shadow:         0,    shear:          0,    rotate:         0,    centered:       1,    faded:          1,    vignette:       1,    perspective:    0};config.shadow = {    left:           0.5,    top:            0.5};config.shear = {    angle:          15};config.rotate = {    angle:          15};config.vignette = {    strength:       20};config.colors = {    saturation:     100,    brightness:     60};/* * Helper Functions */var helpers = {    size: function(obj) {        var rtn = {            height:     obj.geometricBounds[2] - obj.geometricBounds[0],            width:      obj.geometricBounds[3] - obj.geometricBounds[1]        };        rtn.multiplier = config.bounds.width / rtn.width;        return rtn;    },    colors: function(doc, num) {        var rtn = []; // array that holds the swatches        num = num || 10;        for(var i = 0; i < num; i++) {            var myColor = doc.colors.add();            var r = Math.random() * 255;            var g = Math.random() * 255;            var b = Math.random() * 255;            myColor.name       = "rnd color: " + i;            myColor.model      = ColorModel.PROCESS;            myColor.space      = ColorSpace.RGB;            myColor.colorValue = [r, g, b];            myColor_brightness = (0.299 * r + 0.587 * g + 0.114 * b);            rtn.push({ color: myColor, name: myColor.name, brightness: myColor_brightness });        }        return rtn;    },    contrast: function(doc, brightness) {        if(brightness < 200) {            // this is actualy the white swatch            return doc.swatches.item(2);        } else {            // this is actualy the black swatch            return doc.swatches.item(3);        }    },    treshold: function(sensivity, multiplier) {        var opacity = sensivity * multiplier;        if( opacity > 100) opacity = 100;        return opacity;    },    hsl2rgb: function(h, s, l) {        var m1, m2, hue;        var r, g, b;        s /= 100;        l /= 100;        if(s === 0) {            r = g = b = (l * 255);        } else {            if(l <= 0.5) {                m2 = l * (s + 1);            } else {                m2 = l + s - l * s;            }            m1 = l * 2 - m2;            hue = h / 360;            r = this.hue2rgb(m1, m2, hue + 1/3);            g = this.hue2rgb(m1, m2, hue);            b = this.hue2rgb(m1, m2, hue - 1/3);        }        return {r: r, g: g, b: b};    },    hue2rgb: function(m1, m2, hue) {        var v;        if(hue < 0) {            hue += 1;        } else if(hue > 1) {            hue -= 1;        }        if(6 * hue < 1) {            v = m1 + (m2 - m1) * hue * 6;        } else if(2 * hue < 1) {            v = m2;        } else if(3 * hue < 2){            v = m1 + (m2 - m1) * (2/3 - hue) * 6;        } else {            v = m1;        }        return 255 * v;    },    hslRange: function(start, max) {        var rtn = [];        for(var degrees = start; degrees < (start + max); degrees++) {            var radians             = ((degrees/360) % 360) * 2 * Math.PI;            var temp_hue            = degrees; // the hue of the color            var temp_saturation     = config.colors.saturation; // the saturation of the color            var temp_lightness      = config.colors.brightness; // the lighness of the color            var temp_rgb            = this.hsl2rgb(temp_hue, temp_saturation, temp_lightness);            var clrSw = doc.colors.add();// add a color every iteration            clrSw.properties = { /* set some props */              name:         "color " + degrees,              model:        ColorModel.PROCESS,              space:        ColorSpace.RGB,              colorValue:   [temp_rgb.r, temp_rgb.g, temp_rgb.b]            };            var rtnObj = { color: clrSw, brightness: temp_lightness * 2.55 };            rtn.push(rtnObj);        }        return rtn;    }};/* * MAIN SETUP */// add a new documentvar doc = app.documents.add({    documentPreferences: {        pageWidth:      config.pageWidth,        pageHeight:     config.pageHeight,        facingPages:    false    }});// generate 10 random swatches//~ var swatches = helpers.colors(doc, 10);//~ var swatch = swatches[Math.floor(swatches.length * Math.random())];// generate hsl colorsvar swatches = helpers.hslRange(Math.random() * 360, 10);var swatch = swatches[Math.floor(swatches.length * Math.random())];// config colors object// TODO: try to put on top of code :'(config.colors = {    sensivity:  6,    background: swatch.color,    text:       helpers.contrast(doc, swatch.brightness)};// set screenmode to previewapp.activeWindow.screenMode = ScreenModeOptions.PREVIEW_TO_PAGE;// get first page from documentvar page = doc.pages.firstItem();// set page boundariespage.marginPreferences.properties = {    top:                config.margins.top,    right:              config.margins.right,    bottom:             config.margins.bottom,    left:               config.margins.left};// add a background rectangle - lockedvar bg = page.rectangles.add({    geometricBounds:    [                            0,                            0,                            config.pageHeight,                            config.pageWidth                        ],    fillColor:          config.colors.background,    strokeWeight:       0,    locked:             true});// add a radial gradient to the backgroundif(config.customization.vignette) {    // add a seconds rectangle with a black-color    var vignette = page.rectangles.add({        geometricBounds:    [                                0,                                0,                                config.pageHeight,                                config.pageWidth                            ],        fillColor:          doc.swatches.item(3),        strokeWeight:       0,        locked:             true    });    // set the transparency setting    vignette.transparencySettings.blendingSettings.properties = {        blendMode: BlendMode.MULTIPLY,        opacity: config.vignette.strength    };    // set the gradient-type    vignette.transparencySettings.gradientFeatherSettings.properties = {        applied: true,        angle: 90,        type: GradientType.RADIAL    };    // set the first stop opacity    vignette.transparencySettings.gradientFeatherSettings.opacityGradientStops.item(0).properties = {        opacity: 0    };    // set the seconds stop opacity    vignette.transparencySettings.gradientFeatherSettings.opacityGradientStops.item(1).properties = {        opacity: 100    };}/* * GENERATE ALL TEXTFRAMES AND CONVERT TO POLYGONS */var obsRect     = 0;var posObj      = {};for(var i = 0; i < config.contents.length; i++) {    // push to textframes-array    if(config.contents[i] !== '---') {        var tf = page.textFrames.add({            geometricBounds:    [                                    config.bounds.top,                                    config.bounds.left,                                    config.bounds.bottom,                                    config.bounds.right                                ],            contents:           config.contents[i]        });        // get the first paragraph from the textframe        var p = tf.paragraphs.firstItem();        p.properties = {            appliedFont:        config.fontFamily,            fillColor:          config.colors.text        };        // change text to uppercase        p.changecase(ChangecaseMode.UPPERCASE);        // convert to polygons        tf.createOutlines();        // get the polygon and append it to posObj        var pos = 'pos-' + (i + obsRect);        posObj[pos] = page.polygons.firstItem();        // if we dont select the element, it won't work        // looks like a bug to me?        posObj[pos].select();    } else {        // add a rect to the poly array        var line = page.rectangles.add({            geometricBounds: [                                config.bounds.top,                                config.bounds.left,                                config.bounds.top + config.lineHeight,                                config.bounds.right                             ],            // TODO: which color?            // fillColor:       config.colors.text,            fillColor: doc.swatches.item(3),            strokeWeight:    0,            fillTint:        90        });        posObj['pos-' + i] = page.rectangles.firstItem();        config.contents.splice(i, 1);        i--;        obsRect++;    }}/* * SIZE AND POSITION ALL POLYGONS TO THE RIGHT POSITION */var history = {    height: config.bounds.top};// size polygonsfor(var i = 0; i < page.polygons.length; i++) {    var p = page.polygons;    var rev = (page.polygons.length - 1) - i;    var size = helpers.size(p.item(rev));    p.item(rev).resize(        CoordinateSpaces.PAGE_COORDINATES,        AnchorPoint.CENTER_ANCHOR,        ResizeMethods.MULTIPLYING_CURRENT_DIMENSIONS_BY,        [size.multiplier, size.multiplier]    );    if(config.customization.faded) {        p.item(rev).transparencySettings.blendingSettings.properties = {            blendMode: BlendMode.NORMAL,            opacity: helpers.treshold(config.colors.sensivity, size.multiplier)        };    }}// position the objects in the posObj-Objectvar groupArr = [];for(pos in posObj) {    var obj = posObj[pos];    obj.move([config.bounds.left, history.height]);    history.height += helpers.size(obj).height + config.gutter;    groupArr.push(posObj[pos]);}// deselect allapp.activeDocument.select(NothingEnum.NOTHING);// add polyArray to a grouppage.groups.add(groupArr);// get the groupvar group = page.groups.firstItem();/* * ADDITIONAL CUSTOMIZATIONS */// if shadow is turned on, duplicate groupif(config.customization.shadow) {    // duplicate the first group    group.duplicate([        config.bounds.left + config.shadow.left,        config.bounds.top + config.shadow.top    ]).sendBackward();    // get the new duplicated group    var duplicated = page.groups.lastItem();    // fill all polygons to black    duplicated.polygons.everyItem().properties = {        fillColor:  doc.swatches.item(1),        fillTint:   100    };    // fill all rectangles to black    duplicated.rectangles.everyItem().properties = {        fillColor:  doc.swatches.item(1),        fillTint:   100    };}// if shear is turned on, shear it with the transformation matrixif(config.customization.shear) {    var shear = app.transformationMatrices.add();    shear = shear.shearMatrix(config.shear.angle);    group.transform(        CoordinateSpaces.PASTEBOARD_COORDINATES,        AnchorPoint.CENTER_ANCHOR,        shear    );    if(config.customization.shadow) {        duplicated.transform(            CoordinateSpaces.PASTEBOARD_COORDINATES,            AnchorPoint.CENTER_ANCHOR,            shear        );    }}// if rotation is turned on, rotate it with the transformation matrixif(config.customization.rotate) {    var rotate = app.transformationMatrices.add();    rotate = rotate.rotateMatrix(config.rotate.angle);    group.transform(        CoordinateSpaces.PASTEBOARD_COORDINATES,        AnchorPoint.CENTER_ANCHOR,        rotate    );    if(config.customization.shadow) {        duplicated.transform(            CoordinateSpaces.PASTEBOARD_COORDINATES,            AnchorPoint.CENTER_ANCHOR,            rotate);    }}if(config.customization.centered) {    var size = helpers.size(group);    group.move([        (config.pageWidth / 2) - (size.width / 2),        (config.pageHeight / 2) - (size.height / 2)    ]);    if(config.customization.shadow) {        duplicated.move([            (config.pageWidth / 2) - (size.width / 2) + config.shadow.left,            (config.pageHeight / 2) - (size.height / 2) + config.shadow.top        ]);    }}if(config.customization.perspective) {    var size = helpers.size(group);    var depth = 70;    var offset = [50, 50];    offset[0] = depth - offset[0];    offset[1] = depth - offset[1];    // duplicate the first group    for(var i = 0; i < depth; i++) {        group.duplicate([            (config.pageWidth / 2) - (size.width / 2) - (i / offset[0]),            (config.pageHeight / 2) - (size.height / 2) - (i / offset[1])        ]).sendBackward();        // get the new duplicated group        var duplicated = page.groups.firstItem();        // set the transparency setting        duplicated.transparencySettings.blendingSettings.properties = {            blendMode: BlendMode.NORMAL            // opacity: (i * 80) / 100        };        duplicated.polygons.everyItem().properties = {            fillColor: config.colors.background,            fillTint: 100 - (i / 2)        };    }    group.transparencySettings.blendingSettings.properties = {        blendMode: BlendMode.NORMAL,        opacity: 100    };    group.polygons.everyItem().properties = {        fillColor: doc.swatches.item(2),        fillTint: 100    };    group.move([        (config.pageWidth / 2) - (size.width / 2) - (depth / offset[0]),        (config.pageHeight / 2) - (size.height / 2) - (depth / offset[1])    ]);    page.groups.lastItem().transparencySettings.blendingSettings.properties = {        blendMode: BlendMode.NORMAL,        opacity: 0    };}"woosh.";